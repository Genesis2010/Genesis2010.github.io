[ { "title": "[BOJ / Swift] N과 M (2) 15650", "url": "/posts/BOJ-Swift-N%EA%B3%BC-M-(2)-15650/", "categories": "Algorithm, BOJ", "tags": "algorithm, swift, boj, 15650, 백트랙킹", "date": "2022-02-07 22:30:00 +0900", "snippet": "문제자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 고른 수열은 오름차순이어야 한다.입력첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)출력한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.수열은 사전 순으로 증가하는 순서로 출력해야 한다.풀이조건을 만족하는 길이가 M인 수열을 모두 구하는 문제입니다.모든 수열을 구한다는 것은 말 그대로 모든 경우의 수 를 전부 체크를 해야합니다.하지만 이 문제에서는 1부터 N까지 자연수 중에 중복이 없이 M개를 고르고 수열은 오름차순이어야 하는 조건 이 있으므로 완전탐색인 브루트포스 알고리즘이 아닌 백트래킹 알고리즘 을 통해 문제를 해결해야 합니다.순서 입력받은 수를 n과 m에 저장 결과값을 출력하기 위한 String 변수 result 선언 (배열보다 시간 단축) 백트래킹 알고리즘은 재귀함수를 이용하기 때문에 dfs 함수를 선언 결과값을 저장할 temp와 노드의 깊이를 알려줄 depth 매개변수 선언오름차순의 수열을 만들기 위해 반복문에 사용할 start 매개변수 선언 반복문 인덱스 초과 오류를 막기 위해 start가 n보다 작거나 같을 때 실행되도록 조건문 선언 depth 와 m 이 같다는 것은 한 줄에 출력할 수를 골랐기 때문에 result에 저장다른 자식 노드를 가야하기 때문에 return 으로 함수 종료 다음 자식 노드로 탐색해야하기 때문에 dfs 함수를 다시 불러오기 (재귀) 소스 코드let input = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}let n = input[0]let m = input[1]var result = &quot;&quot;func dfs(start: Int, depth: Int, temp: String) { if depth == m { result += &quot;\\(temp)\\n&quot; return } if start &amp;lt;= n { for i in start...n { dfs(start: i + 1, depth: depth + 1, temp: temp + &quot;\\(i) &quot;) } }}dfs(start: 1, depth: 0, temp: &quot;&quot;)print(result)출처https://www.acmicpc.net/problem/15650" }, { "title": "[BOJ / Swift] N과 M (1) 15649", "url": "/posts/BOJ-Swift-N%EA%B3%BC-M-(1)-15649/", "categories": "Algorithm, BOJ", "tags": "algorithm, swift, boj, 15649, 백트랙킹", "date": "2022-02-05 11:30:00 +0900", "snippet": "문제자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열입력첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)출력한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.수열은 사전 순으로 증가하는 순서로 출력해야 한다.풀이조건을 만족하는 길이가 M인 수열을 모두 구하는 문제입니다.모든 수열을 구한다는 것은 말 그대로 모든 경우의 수 를 전부 체크를 해야합니다.하지만 이 문제에서는 1부터 N까지 자연수 중에 중복이 없이 M개를 골라야 하는 조건 이 있으므로 완전탐색인 브루트포스 알고리즘이 아닌 백트래킹 알고리즘 을 통해 문제를 해결해야 합니다.순서 입력받은 수를 n과 m에 저장 해당 노드를 방문했는지 확인을 위한 Bool형 배열 (visited) 선언 결과값을 출력하기 위한 String 변수 result 선언 (배열보다 시간 단축) 백트래킹 알고리즘은 재귀함수를 이용하기 때문에 dfs 함수를 선언 결과값을 저장할 temp와 노드의 깊이를 알려줄 depth 매개변수 선언 depth 와 m 이 같다는 것은 한줄에 출력할 수를 골랐기 때문에 result에 저장다른 자식 노드를 가야하기 때문에 return 으로 함수 종료 visited의 각 인덱스 마다 방문하지 않았다면 (false) 방문한것으로 바꾸기 (true) 다음 자식 노드로 탐색해야하기 때문에 dfs 함수를 다시 불러오기 (재귀) n번만큼 반복문이 돌았다면 부모 노드로 돌아가고 방문했던 노드는 false로 바꾸기 소스 코드let input = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}let n = input[0]let m = input[1]var visited = Array(repeating: false, count: n+1)var result = &quot;&quot;func dfs (depth: Int, temp: String) { if depth == m { result += &quot;\\(temp)\\n&quot; return } for i in 1...n { if !visited[i] { visited[i] = true dfs(depth: depth + 1, temp: temp + &quot;\\(i) &quot;) visited[i] = false } }}dfs(depth: 0, temp: &quot;&quot;)print(result)출처https://www.acmicpc.net/problem/15649" }, { "title": "[BOJ / Swift] 스택 수열 1874", "url": "/posts/BOJ-Swift-%EC%8A%A4%ED%83%9D-%EC%88%98%EC%97%B4-1874/", "categories": "Algorithm, BOJ", "tags": "algorithm, swift, boj, 1874, 스택", "date": "2022-02-02 12:30:00 +0900", "snippet": "문제스택 (stack)은 기본적인 자료구조 중 하나로, 컴퓨터 프로그램을 작성할 때 자주 이용되는 개념이다.스택은 자료를 넣는 (push) 입구와 자료를 뽑는 (pop) 입구가 같아 제일 나중에 들어간 자료가 제일 먼저 나오는 (LIFO, Last in First out) 특성을 가지고 있다.1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자.임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지를 알아낼 수 있다. 이를 계산하는 프로그램을 작성하라.입력첫 줄에 n (1 ≤ n ≤ 100,000)이 주어진다.둘째 줄부터 n개의 줄에는 수열을 이루는 1이상 n이하의 정수가 하나씩 순서대로 주어진다. 물론 같은 정수가 두 번 나오는 일은 없다.출력입력된 수열을 만들기 위해 필요한 연산을 한 줄에 한 개씩 출력한다.push연산은 +로, pop 연산은 -로 표현하도록 한다. 불가능한 경우 NO를 출력한다.풀이1부터 n까지의 수를 스택 을 활용하여 입력한 수열처럼 만들어야 하는 문제입니다.스택은 LIFO ( Last in First Out ) 특성의 자료구조로 가장 마지막에 들어온 자료가 제일 먼저 나가는 특성 을 갖고 있습니다.1부터 n까지의 수를 스택에 넣어야 하므로 count 라는 변수를 만들어 스택에 저장했습니다.또한 해당 수열을 만들 수 있는지 없는지 확인하기 위해 state 변수를 따로 만들어 주었습니다.순서 해당 수만큼 반복하여 stack에 push 하기 ( count 값 ), ‘+’ 는 result 에 저장 stack에 제일 나중에 들어온 수와 count가 같으면 pop 하기, ‘-‘ 는 result 에 저장 해당 수열을 만들 수 없다면 state 를 false 로 바꾸기 가능한 경우는 result 를 출력, 불가능한 경우는 NO 를 출력 소스 코드let n = Int(readLine()!)!var count = 1var stack = [Int]()var result = [Character]()var state = truefor _ in 0..&amp;lt;n { let num = Int(readLine()!)! while count &amp;lt;= num { stack.append(count) result.append(&quot;+&quot;) count += 1 } if stack.last == num { stack.removeLast() result.append(&quot;-&quot;) } else { state = false }}if state { for i in result { print(i) }} else { print(&quot;NO&quot;)}" }, { "title": "[BOJ / Swift] 사탕 게임 3085", "url": "/posts/BOJ-Swift-%EC%82%AC%ED%83%95-%EA%B2%8C%EC%9E%84-3085/", "categories": "Algorithm, BOJ", "tags": "algorithm, swift, boj, 3085, 브루트포스, 정렬", "date": "2022-02-01 12:30:00 +0900", "snippet": "문제상근이는 어렸을 적에 “봄보니 (Bomboni)” 게임을 즐겨했다.가장 처음에 N×N크기에 사탕을 채워 놓는다. 사탕의 색은 모두 같지 않을 수도 있다. 상근이는 사탕의 색이 다른 인접한 두 칸을 고른다. 그 다음 고른 칸에 들어있는 사탕을 서로 교환한다.이제, 모두 같은 색으로 이루어져 있는 가장 긴 연속 부분(행 또는 열)을 고른 다음 그 사탕을 모두 먹는다.사탕이 채워진 상태가 주어졌을 때, 상근이가 먹을 수 있는 사탕의 최대 개수를 구하는 프로그램을 작성하시오.입력첫째 줄에 보드의 크기 N이 주어진다. (3 ≤ N ≤ 50)다음 N개 줄에는 보드에 채워져 있는 사탕의 색상이 주어진다. 빨간색은 C, 파란색은 P, 초록색은 Z, 노란색은 Y로 주어진다.사탕의 색이 다른 인접한 두 칸이 존재하는 입력만 주어진다.출력첫째 줄에 상근이가 먹을 수 있는 사탕의 최대 개수를 출력한다.풀이해당 배열의 모든 요소를 행과 열 방향으로 요소를 바꾸고 원위치를 시켜야 하기 때문에 처음부터 끝까지 직접 탐색하는 브루트포스 알고리즘 을 사용했습니다.요소를 바꾸거나 행, 열 중 사탕의 최대 개수를 구하는 알고리즘은 함수로 구현을 했습니다.swapRow , swapColumn 은 행, 열 방향의 요소를 서로 바꾸는 역할을 하며sameRow , sameColumn 은 행, 열 방향의 연속된 사탕의 최대 개수를 구하는 역할 입니다.순서 N x N 의 배열 만들고 요소 입력하기 행에서 다음 인덱스의 요소와 바꾸고 배열에서 행, 열 중 사탕의 최대 개수 구하기 바꾼 요소들을 원위치 시키기 열에서 다음 인덱스의 요소와 바꾸고 배열에서 행, 열 중 사탕의 최대 개수 구하기 바꾼 요소들을 원위치 시키기 구한 수 중 가장 큰 수 출력하기 소스 코드let n = Int(readLine()!)!var resultRow = [Int]()var resultColumn = [Int]()var arr = Array(repeating: Array(repeating: &quot;Z&quot;, count: n), count: n)for i in 0..&amp;lt;n { arr[i] = readLine()!.map{ String($0) }}for i in 0..&amp;lt;n { for j in 0..&amp;lt;n-1 { if arr[i][j] == arr[i][j+1] { continue } else { swapRow(i, j) resultRow.append(max(sameRow(), sameColumn())) swapRow(i, j) } }}for i in 0..&amp;lt;n { for j in 0..&amp;lt;n-1 { if arr[j][i] == arr[j+1][i] { continue } else { swapColumn(j, i) resultColumn.append(max(sameRow(), sameColumn())) swapColumn(j, i) } }}print(max(resultRow.max()!, resultColumn.max()!))func swapRow(_ r: Int, _ c: Int) { let temp = arr[r][c] arr[r][c] = arr[r][c + 1] arr[r][c + 1] = temp }func swapColumn(_ r: Int, _ c: Int) { let temp = arr[r][c] arr[r][c] = arr[r + 1][c] arr[r + 1][c] = temp}func sameRow() -&amp;gt; Int { var max = 0 for i in 0..&amp;lt;n { var same = 1 for j in 0..&amp;lt;n-1 { if arr[i][j] == arr[i][j+1] { same += 1 } else { same = 1 } if max &amp;lt; same { max = same } } } return max}func sameColumn() -&amp;gt; Int { var max = 0 for i in 0..&amp;lt;n { var same = 1 for j in 0..&amp;lt;n-1 { if arr[j][i] == arr[j+1][i] { same += 1 } else { same = 1 } if max &amp;lt; same { max = same } } } return max}" }, { "title": "[BOJ / Swift] 일곱 난쟁이 2309", "url": "/posts/BOJ-Swift-%EC%9D%BC%EA%B3%B1-%EB%82%9C%EC%9F%81%EC%9D%B4-2309/", "categories": "Algorithm, BOJ", "tags": "algorithm, swift, boj, 2309, 브루트포스, 정렬", "date": "2022-01-27 21:30:00 +0900", "snippet": "문제왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.아홉 명의 난쟁이는 모두 자신이 “백설 공주와 일곱 난쟁이”의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.입력아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다.주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.출력일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.풀이합이 100이 되는 7개의 수를 찾야할 때 어떻게 7개의 수를 다르게 조합하여 더할 수 있을까? 라는 생각을 했습니다.고민을 하다 보니 9개의 수를 다 더한 후 2개의 수를 빼서 100이 되는 조합 을 찾는 것이 더욱 좋을거 같다 생각했습니다.모든 경우의 수를 찾아야 하기 때문에 처음부터 끝까지 직접 탐색하는 브루트포스 알고리즘 을 사용했습니다.순서 9개의 수를 입력받고 총합 구하기 두개의 경우를 찾아야 하기 때문에 배열을 전체 탐색 경우의 수 중복과 시간을 줄이기 위해 두번째 반복문은 i + 1 부터 탐색 차가 100이 되는 두 수를 찾고 배열에서 인덱스로 요소를 삭제 배열 요소 개수가 7이면 찾은 것이므로 break 로 반복문 빠져나오기 다른 분들의 풀이를 보니 요소를 삭제하기 보다 filter 를 통해 두 수를 제외한 나머지를 출력하는 방법도 있었습니다.참고하시면 좋을거 같습니다!소스 코드var arr = [Int]()for _ in 0..&amp;lt;9 { arr.append(Int(readLine()!)!)}var sum = arr.reduce(0, +)for i in 0..&amp;lt;arr.count - 1 { for j in i+1..&amp;lt;arr.count { if sum - arr[i] - arr[j] == 100 { arr.remove(at:i) arr.remove(at:j-1) break } } if arr.count == 7 { break }}for i in arr.sorted() { print(i)}" }, { "title": "[BOJ / Swift] 최대공약수와 최소공배수 2609", "url": "/posts/BOJ-Swift-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98-2609/", "categories": "Algorithm, BOJ", "tags": "algorithm, swift, boj, 2609, 최대공약수, 최소공배수", "date": "2022-01-19 00:00:00 +0900", "snippet": "문제두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오.입력첫째 줄에는 두 개의 자연수가 주어진다. 이 둘은 10,000이하의 자연수이며 사이에 한 칸의 공백이 주어진다.출력첫째 줄에는 입력으로 주어진 두 수의 최대공약수를, 둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다풀이최대공약수최대공약수를 구하는 방법에는 여러가지가 있겠지만 유클리드 호제법 이 가장 쉬운 방법 중 하나입니다.두 자연수 a, b에 대해서 a를 b로 나눈 나머지가 r이라면 a와 b의 최대공약수는 b와 r의 최대공약수와 같습니다.더욱 쉽게 말하자면 위의 과정을 연속해 나머지가 0이 나올때 까지 나누면 그 수가 최대공약수 입니다.최소공배수최소공배수는 최대공약수 보다 더욱 구하기 쉽습니다.두 수 a, b의 최소공배수는 a와 b의 곱을 a와 b의 최대공약수로 나눈 것 과 같습니다.첫번째 방법첫번째 방법은 최대공약수와 최소공배수를 구하는 함수를 따로 만들어 반환값을 출력하는 방법 을 선택했습니다.최대공약수를 구할때 나머지가 0이 나올떄 까지 나눠야 하기 떄문에 재귀함수 로 구현을 하였습니다.재귀함수로 구현해서 그런지 두번째 방법보다 시간이 더 오래걸렸습니다…..두번째 방법두번째 방법은 함수로 구현하지 않고 푸는 방법을 선택했습니다.테스트 입력은 큰 수가 먼저 입력되지만 꼭 그런 경우는 없기 때문에 큰 수와 작은 수를 먼저 분리 했습니다.그 다음 나머지가 0이 될때까지 반복문 을 통해 최대공약수를 구했고 최소공배수 또한 간단한 식으로 구했습니다.다행히도 첫번째 방법보다 훨씬 단축되었습니다.소스 코드첫번째 방법func gcd(_ a : Int, _ b: Int) -&amp;gt; Int { let mod = a % b return mod == 0 ? min(a, b) : gcd(b, mod)}func lcm(_ a : Int, _ b: Int) -&amp;gt; Int { return (a * b) / gcd(a, b)}let num = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!}print(gcd(num[0], num[1]))print(lcm(num[0], num[1]))두번째 방법let num = readLine()!.split(separator: &quot; &quot;).map{Int(String($0))!} var a = max(num[0], num[1])var b = min(num[0], num[1]) while a % b != 0 { let temp = a % b a = b b = temp} print(b)print(num[0] * num[1] / b)" }, { "title": "[BOJ / Swift] 괄호 9012", "url": "/posts/BOJ-Swift-%EA%B4%84%ED%98%B8-9012/", "categories": "Algorithm, BOJ", "tags": "algorithm, swift, boj, 9012, 괄호, 스택", "date": "2022-01-17 22:00:00 +0900", "snippet": "문제괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다.그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다.한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다.만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다.그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다.예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다.여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다.입력입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다.입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다.각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다.하나의 괄호 문자열의 길이는 2 이상 50 이하이다.출력출력은 표준 출력을 사용한다.만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다.풀이이 문제는 “ ( “ 와 “ ) “ 가 순서대로 스택에 존재 했을 때 올바른 괄호 문자열이 됩니다.즉, &quot;)&quot; 가 먼저 입력이 된다면 올바르지 않은 괄호 문자열입니다.&quot;(&quot; 가 입력 된다면 스택에 넣고 &quot;)&quot; 가 입력 되었을 때는 스택이 비어있는지 확인 을 해야합니다.만약 비어 있다면 올바르지 않은 괄호 문자열 이므로 for문을 벗어납니다.비어 있지 않다면 스택에 먼저 “(“ 가 있는 것이므로 스택에 있는 &quot;(&quot; 를 지워 줍니다.스택이 비어있다면 올바른 괄호 문자열 ( YES ) 이고 비어있지 않다면 올바르지 않은 괄호 문자열 ( NO ) 를 출력해 줍니다.마지막으로 다음 문자열을 받기 위해 스택을 비워 줍니다.소스 코드let n = Int(readLine()!)!var stack = [Character]()for _ in 0..&amp;lt;n { let input = readLine()! for i in input { if i == &quot;(&quot; { stack.append(i) } else { if stack.isEmpty { stack.append(i) break } else { stack.removeLast() } } } print(stack.isEmpty ? &quot;YES&quot; : &quot;NO&quot;) stack = []}" }, { "title": "[BOJ / Swift] 단어 뒤집기 9093", "url": "/posts/BOJ-Swift-%EB%8B%A8%EC%96%B4-%EB%92%A4%EC%A7%91%EA%B8%B0-9093/", "categories": "Algorithm, BOJ", "tags": "algorithm, swift, boj, 9093, 단어뒤집기, 문자열", "date": "2022-01-12 23:30:00 +0900", "snippet": "문제문장이 주어졌을 때, 단어를 모두 뒤집어서 출력하는 프로그램을 작성하시오.단, 단어의 순서는 바꿀 수 없다. 단어는 영어 알파벳으로만 이루어져 있다.입력첫째 줄에 테스트 케이스의 개수 T가 주어진다.각 테스트 케이스는 한 줄로 이루어져 있으며, 문장이 하나 주어진다.단어의 길이는 최대 20, 문장의 길이는 최대 1000이다. 단어와 단어 사이에는 공백이 하나 있다.출력각 테스트 케이스에 대해서, 입력으로 주어진 문장의 단어를 모두 뒤집어 출력한다.풀이문자열을 띄어쓰기로 자른 뒤 각 문자열을 reversed() 로 뒤집고다른 배열에 다시 집어 놓고 joined() 를 통해 각 원소를 합칠 때 띄어쓰기를 포함하도록 했습니다.중요한 것은 reversed()를 사용 시 반환 값은 ReversedCollection&amp;lt;Array&amp;lt;Element&amp;gt;&amp;gt;&amp;gt; 이기 때문에바로 사용하는 것이 아닌 for 문 을 통하여 각 문자를 출력해주어야 합니다.소스 코드let n = Int(readLine()!)!for _ in 0..&amp;lt;n { let input = readLine()!.split(separator: &quot; &quot;).map{String($0)} var arr = [String]() for i in input { var temp = &quot;&quot; for j in i.reversed() { temp += String(j) } arr.append(temp) } let result = arr.joined(separator: &quot; &quot;) print(result)}" }, { "title": "[BOJ / Swift] 나머지 3052", "url": "/posts/BOJ-Swift-%EB%82%98%EB%A8%B8%EC%A7%80-3052/", "categories": "Algorithm, BOJ", "tags": "algorithm, swift, boj", "date": "2022-01-11 00:30:00 +0900", "snippet": "문제두 자연수 A와 B가 있을 때, A%B는 A를 B로 나눈 나머지 이다.예를 들어, 7, 14, 27, 38을 3으로 나눈 나머지는 1, 2, 0, 2이다.수 10개를 입력받은 뒤, 이를 42로 나눈 나머지를 구한다.그 다음 서로 다른 값이 몇 개 있는지 출력하는 프로그램을 작성하시오.입력첫째 줄부터 열번째 줄 까지 숫자가 한 줄에 하나씩 주어진다.이 숫자는 1,000보다 작거나 같고, 음이 아닌 정수이다.출력첫째 줄에, 42로 나누었을 때, 서로 다른 나머지가 몇 개 있는지 출력한다.풀이Swift 에서는 Array, Dictionary, Set 이라는 컬렉션 타입이 있습니다.그중에서 Set 은 순서가 없고, 멤버가 유일한 컬렉션 을 의미합니다.즉, 서로 다른 나머지를 찾는 방법 중 가장 간단한 방법은 나머지를 Set에 저장하여 중복 을 없애는 것입니다.소스 코드var num: Set&amp;lt;Int&amp;gt; = []for _ in 1...10 { num.insert(Int(readLine()!)! % 42)}print(num.count)" }, { "title": "[BOJ / Swift] 네번째 점 3009", "url": "/posts/BOJ-Swift-%EB%84%A4%EB%B2%88%EC%A7%B8-%EC%A0%90-3009/", "categories": "Algorithm, BOJ", "tags": "algorithm, swift, boj", "date": "2022-01-09 01:25:00 +0900", "snippet": "문제세 점이 주어졌을 때, 축에 평행한 직사각형을 만들기 위해서 필요한 네 번째 점을 찾는 프로그램을 작성하시오.입력세 점의 좌표가 한 줄에 하나씩 주어진다. 좌표는 1보다 크거나 같고, 1000보다 작거나 같은 정수이다.출력직사각형의 네 번째 점의 좌표를 출력한다.풀이처음 문제를 접했을 때 변의 길이를 구하여 네번째 점을 구하려 했지만각 점의 규칙을 찾아보니 평행한 직사각형을 만들기 위해서는 x 좌표값과 y 좌표값이 각각 2번씩 나와야합니다.x, y 좌표를 각 배열에 넣고 for문을 통해 1개인 x, y 좌표 값 을 찾아 출력을 했습니다.소스 코드let first = readLine()!.split(separator: &quot; &quot;).map{Int(String( $0 ))!}let second = readLine()!.split(separator: &quot; &quot;).map{Int(String( $0 ))!}let third = readLine()!.split(separator: &quot; &quot;).map{Int(String( $0 ))!}var last : [Int] = []for i in 0..&amp;lt;first.count { if first[i] == second[i] { last.append(third[i]) } else if first[i] == third[i] { last.append(second[i]) } else if second[i] == third[i] { last.append(first[i]) }}print(last[0], last[1])" }, { "title": "[BOJ / Swift] A+B-4 10951", "url": "/posts/BOJ-Swift-A+B_4-10951/", "categories": "Algorithm, BOJ", "tags": "algorithm, swift, boj", "date": "2022-01-05 14:00:00 +0900", "snippet": "문제두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.입력입력은 여러 개의 테스트 케이스로 이루어져 있다.각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &amp;lt; A, B &amp;lt; 10)출력각 테스트 케이스마다 A+B를 출력한다.풀이해당 문제는 두 수를 더해 출력하는 아주 쉬운 문제이지만검색을 해서 풀이를 보고 있다는 것은 아마 계속해서 런타임 에러가 나왔을 것입니다.이 문제에서 가장 중요한 것은 무한 루프가 돌 때 어떻게 빠져나올 것인지에 관한 문제 입니다.계속 입력하는 것이 아니기 때문에 while 문의 조건을 true 가 아닌 입력을 받았을 때만 반복 하도록 하여야합니다.소스 코드while let input = readLine(){ print(input.split(separator: &quot; &quot;).map{Int(String( $0 ))!}.reduce(0, +))}" }, { "title": "[BOJ / Swift] 한수 1065", "url": "/posts/BOJ-Swift-%ED%95%9C%EC%88%98-1065/", "categories": "Algorithm, BOJ", "tags": "algorithm, swift, boj", "date": "2022-01-04 23:00:00 +0900", "snippet": "문제어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다.등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다.N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오.입력첫째 줄에 1,000보다 작거나 같은 자연수 N이 주어진다.출력첫째 줄에 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력한다.풀이처음에 한수가 무엇인지 이해하지 못해 문제를 파악하기까지 오랜 시간이 걸렸습니다.아직까지도 1부터 99까지의 수가 한수인지 정확한 해답을 말하기가 어려운 부분입니다.문제에서 각 자리의 수가 등차수열을 이룬다면 한수라고 한다는 것은각 자리의 수의 차이가 일정하면 한수입니다.예를 들자면 한자리 수는 비교 대상이 없으므로 그 자체로 한수 이고. 두자리 수는 수의 차이가 1개 밖에 없으므로 한수 입니다.따라서 입력 대상은 1000보다 작거나 같은 수 이므로 세자리 수인 100부터 999까지 범위 만 찾으면 되는 것 입니다.1000은 한수가 아니기 때문에 미리 제외를 시켰습니다.앞서 말한 것처럼 1부터 99까지의 수는 모두 한수이기 때문에 입력한 수의 크기가 한수의 개수이고 100이상의 수 부터는 각 자리로 나누어 각 차이를 계산하게 됩니다.첫째자리는 100을 나누어 몫 으로, 둘째 자리는 100을 나눈 나머지에 다시 10으로 나눈 몫 , 셋째 자리는 10으로 나눈 나머지 로 분류하였습니다.이제 한수인지 판별을 해야하기 때문에 둘째 자리와 첫째 자리의 차이 , 셋째 자리와 둘째 자리의 차이 를 구하였고같을 시 한수 이므로 count에 1씩 더해주었습니다.소스 코드let num = Int(readLine()!)! // 입력받은 수var count = 0 // 한수의 개수func cal (_ num: Int) -&amp;gt; Int{ // 한수를 찾기 위한 함수 for i in 100...num { let firstNum = i/100 let secondNum = i % 100 / 10 let thirdNum = i % 10 if secondNum - firstNum == thirdNum - secondNum { count += 1 } } count += 99 return count}if num &amp;gt;= 100 { print(cal(num))} else { count += num print(count)}" } ]
