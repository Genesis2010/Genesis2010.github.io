---
title: '[BOJ / Swift] 최대공약수와 최소공배수 2609'
author: Genesis
date: 2022-01-18 23:00:00 +0800
categories: [Algorithm, BOJ]
tags: [algorithm, swift, boj, '2609', 최대공약수, 최소공배수]
---

## __문제__
***
두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오.

## __입력__
***
첫째 줄에는 두 개의 자연수가 주어진다. 이 둘은 10,000이하의 자연수이며 사이에 한 칸의 공백이 주어진다.

## __출력__
***
첫째 줄에는 입력으로 주어진 두 수의 최대공약수를, 둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다

![BOJ_2609](/assets/img/Algorithm/BOJ_2609.png)

## __풀이__
***

### __최대공약수__

최대공약수를 구하는 방법에는 여러가지가 있겠지만 __`유클리드 호제법`__ 이 가장 쉬운 방법 중 하나입니다.

두 자연수 a, b에 대해서 a를 b로 나눈 나머지가 r이라면 a와 b의 최대공약수는 b와 r의 최대공약수와 같습니다.

더욱 쉽게 말하자면 위의 과정을 연속해 __`나머지가 0이 나올때 까지 나누면`__ 그 수가 __`최대공약수`__입니다.

### __최소공배수__

최소공배수는 최대공약수 보다 더욱 구하기 쉽습니다. 

두 수 a, b의 최소공배수는 __`a와 b의 곱을 a와 b의 최대공약수로 나눈 것`__ 과 같습니다.

### __첫번째 방법__

첫번째 방법은 최대공약수와 최소공배수를 구하는 __`함수를 따로 만들어 반환값을 출력하는 방법`__ 을 선택했습니다.

최대공약수를 구할때 나머지가 0이 나올떄 까지 나눠야 하기 떄문에 __`재귀함수`__ 로 구현을 하였습니다.

재귀함수로 구현해서 그런지 두번째 방법보다 시간이 더 오래걸렸습니다.....

### __두번째 방법__

두번째 방법은 함수로 구현하지 않고 푸는 방법을 선택했습니다.

테스트 입력은 큰 수가 먼저 입력되지만 꼭 그런 경우는 없기 때문에 __`큰 수와 작은 수를 먼저 분리`__ 했습니다.

그 다음 나머지가 0이 될때까지 __`반복문`__ 을 통해 최대공약수를 구했고 최소공배수 또한 간단한 식으로 구했습니다.

다행히도 첫번째 방법보다 훨씬 단축되었습니다.

## __소스 코드__
***

### __첫번째 방법__

```swift
func gcd(_ a : Int, _ b: Int) -> Int {
    let mod = a % b
    return mod == 0 ? min(a, b) : gcd(b, mod)
}

func lcm(_ a : Int, _ b: Int) -> Int {
    return (a * b) / gcd(a, b)
}

let num = readLine()!.split(separator: " ").map{Int(String($0))!}

print(gcd(num[0], num[1]))
print(lcm(num[0], num[1]))
```

### __두번째 방법__

```swift
let num = readLine()!.split(separator: " ").map{Int(String($0))!}
 
var a = max(num[0], num[1])
var b = min(num[0], num[1])
 
while a % b != 0 {
    let temp = a % b
    a = b
    b = temp
}
 
print(b)
print(num[0] * num[1] / b)
```
